/**
 * Created by marian3525.
 * Code for the slave board which takes inputs from the buttons, ENCODERODERoders and temperature sensors, packs them in a byte array and sends them over SPI to the Raspberry PI master
 * Arduino Nano (ATmega328P, 16MHz, 3.3V, 4MHz SPI speed)
 * 
 * Sampling cycle:
 * If it isn't the time to send the buffer, check to see if the ENCODERODERoders have rotated and increment the counters
 *                                          check if any buttons have been pressed and save a 255 in the buffer at their status position if they have
*/
#include "WProgram.h"
#include "constants_inputBoard.h"
using namespace pin;

const uint8_t buffer_size = 12;

uint8_t* buffer;	                                          // SPI data buffer
int last_update;
int delta;
bool sampled = false;
bool dataReady = false;

// ENCODERODERoder pin status. [channel][type][pin]_last/now
uint8_t avp1_last=false, avp1_now=false;
uint8_t avp2_last=false, avp2_now=false;
int ENCODERAV=0;

uint8_t aap1_last=false, aap1_now=false;
uint8_t aap2_last=false, aap2_now=false;
int ENCODERAA=0;

uint8_t bvp1_last=false, bvp1_now=false;
uint8_t bvp2_last=false, bvp2_now=false;
int ENCODERBV=0;

uint8_t bap1_last=false, bap1_now=false;
uint8_t bap2_last=false, bap2_now=false;
int ENCODERBA=0;

uint8_t currentMode;

//temperature map. temp[resistance in kOhms] = temperature;
const float temp[101] = {159.9, 152.2, 144.9, 138, 131.4, 125.2, 119.4, 113.8, 108.5, 103.5,
					                98,   942,   89.9,  85.8, 81.9, 78.2,  74.7,  71.4,  68.2,  65.2,
					                62.3, 59.6,  57,    54.5, 52.2, 50,    47.8,  45.8,  43.8,  42,  40.2,
					                38.5, 36.9,  35.4,  33.9, 32.6, 31.2,  29.9,  28.7,  27.6,  26.5,
					                25.4, 24.4,  23.4,  22.5, 21.6, 20.8,  20,    19.2,  18.4,  17.9,
					                17.1, 16.4,  15.8,  15.2, 14.6, 14.1,  13.5,  13,    12.6,  12.1, 
					                11.7, 11.2,  10.8,  10.4, 10,   9.7,   9.4,    9,     8.7,   8.4, 
					                8.1,   7.8,   7.5,   7.3,  7,   6.8,   6.5,   6.3,    6.1,   5.9, 
					                5.7,   5.5,   5.3,   5.1,  5,   4.8,   4.7,   4.5,    4.4,   4.2, 
					                4.1,   3.9,   3.8,   3.7, 3.6,  3.5,   3.4,   3.3,    3.2,   3.1};

void sampleEncoders() {
  	avp1_last = avp1_now;
  	avp1_now = digitalRead(ENCODER_VOLTAGE_A_P1);
  	avp2_last = avp2_now;
  	avp2_now = digitalRead(ENCODER_VOLTAGE_A_P2);
  	
  	aap1_last = aap1_now;
  	aap1_now = digitalRead(ENCODER_CURRENT_A_P1);
  	aap2_last = aap2_now;
  	aap2_now = digitalRead(ENCODER_CURRENT_A_P2);
  	
  	bvp1_last = bvp1_now;
  	bvp1_now = digitalRead(ENCODER_VOLTAGE_B_P1);
  	bvp2_last = bvp2_now;
  	bvp2_now = digitalRead(ENCODER_VOLTAGE_B_P2);
  	
  	bap1_last = bap1_now;
  	bap1_now = digitalRead(ENCODER_CURRENT_B_P1);
  	bap2_last = bap2_now;
  	bap2_now = digitalRead(ENCODER_CURRENT_B_P2);
  	
  	//trigger on the rising edge after both of them were LOW
  	if(avp1_last == avp2_last && avp1_last == false) {
  		  if(avp1_now == true && avp2_now == false)
  			    ENCODERAV++;
  		  if(avp1_now == false && avp2_now == true)
  			    ENCODERAV--;
  	}
  	
  	if(aap1_last == aap2_last && aap1_last == false) {
  		  if(aap1_now == true && aap2_now == false)
  			    ENCODERAA++;
  		  if(aap1_now == false && aap2_now == true)
  			    ENCODERAA--;
  	}
  	
  	if(bvp1_last == bvp2_last && bvp1_last == false) {
  		  if(bvp1_now == true && bvp2_now == false)
  			    ENCODERBV++;
  		  if(bvp1_now == false && bvp2_now == true)
  			    ENCODERBV--;
  	}
  	
  	if(bap1_last == bap2_last && bap1_last == false) {
  		  if(bap1_now == true && bap2_now == false)
  			    ENCODERBA++;
  		  if(bap1_now == false && bap2_now == true)
  			    ENCODERBA--;
  	}
}

void setup() {
  	buffer = new char[buffer_size];
    
  	pinMode(BUTTON_NEXT, INPUT);
  	pinMode(BUTTON_PREVIOUS, INPUT);
  	pinMode(BUTTON_SELECT, INPUT);
  	pinMode(BUTTON_AUX, INPUT);
  	
  	pinMode(PSU_TEMPERATURE_SENSE, INPUT);
  	pinMode(CHANNELA_TEMPERATURE_SENSE, INPUT);
  	pinMode(CHANNELB_TEMPERATURE_SENSE, INPUT);
  	
  	pinMode(ENCODER_VOLTAGE_A_P1, INPUT);
  	pinMode(ENCODER_VOLTAGE_A_P2, INPUT);
  	pinMode(ENCODER_CURRENT_B_P1, INPUT);
  	pinMode(ENCODER_CURRENT_B_P2, INPUT);
  	
  	pinMode(ENCODER_VOLTAGE_B_P1, INPUT);
  	pinMode(ENCODER_VOLTAGE_B_P2, INPUT);
  	pinMode(ENCODER_CURRENT_B_P1, INPUT);
  	pinMode(ENCODER_CURRENT_B_P2, INPUT);
  	
	  pinMode(CURRENT_MODE, INPUT);

    pinMode(SCK, INPUT);                    // clock generated by master. Should be at most 4MHz or most data will be lost.
    pinMode(pin::MOSI, INPUT);                   // MOSI should be high impedance when not talked to
    pinMode(pin::MISO, INPUT);                   // MISO is always input
    pinMode(pin::SS, INPUT);                     // brought LOW when the transfer is started
    
    SPCR |= _BV(SPE);                       // enable SPI as slave
}
					
int getTempFromTable(float resistance) {
	/*
		Find the closest aproximation of the temperature from the temp map
		resistance given in Ohms
	*/
	
  	resistance /= 1000;
  	int middle, left = 0, right = 100;
  	while (true) {
  		  middle = (left + right) / 2;
  
  		  if (left - right <= 4) {
  			  float min_delta = 99;
  			  int idx;
  			  for (int i = left; i <= right; i++) {
  				  float delta = abs(resistance - temp[i]);
  				  if (delta < min_delta) {
  					  min_delta = delta;
  					  idx = i;
  				  }
  			  }
  			  return idx;
  		  }
  		  else if (temp[middle] >= resistance) {
  			  //search in the right half
  			  left = middle;
  		  }
  		  else {
  			  //search in the left half
  			  right = middle;
  		  }
  	 }
}

inline int8_t getTemperaturePSU(int digitalValue) {
  	int R_pulldown=10000;
  	return getTempFromTable(R_pulldown*(5-digitalValue/1023.0*5)/(digitalValue/1023.0*5));
}
inline int8_t getTemperatureCHA(int digitalValue) {
  	int R_pulldown=10000;
  	return getTempFromTable(R_pulldown*(5-digitalValue/1023.0*5)/(digitalValue/1023.0*5));
}
inline int8_t getTemperatureCHB(int digitalValue) {
  	int R_pulldown=10000;
  	return getTempFromTable(R_pulldown*(5-digitalValue/1023.0*5)/(digitalValue/1023.0*5));
}

void sampleInput() {
  	sampleEncoders();

    // keep a 1 if the button has already been pressed this cycle (also achieves soft debouncing)
    // will be set back to 0 after the data has been sent
  	buffer[0] = digitalRead(BUTTON_NEXT) > buffer[0] ? 0xFF: 0x00;
  	buffer[1] = digitalRead(BUTTON_PREVIOUS) > buffer[1] ? 0xFF: 0x00;
  	buffer[2] = digitalRead(BUTTON_SELECT) > buffer[2] ? 0xFF : 0x00;
  	buffer[3] = digitalRead(BUTTON_AUX) > buffer[3]? 0xFF : 0x00;
  
  	buffer[7] = ENCODERAV ? 0xFF : 0x00;
  	buffer[8] = ENCODERAA ? 0xFF : 0x00;
  	buffer[9] = ENCODERBV? 0xFF : 0x00;
  	buffer[10] = ENCODERBA ? 0xFF : 0x00;

  	buffer[11] = digitalRead(CURRENT_MODE) ? 0xFF : 0x00;      // this button is a latching one, so it will hold its state
}


bool usingMISO = false;

inline byte SPISendByte(const byte value) {
  /**
   * Send one byte, takes 2us per byte
   */
    SPDR = value;                                   // set value to be sent to the master
    while (!(SPSR & (1 << SPIF))){};                // wait for the transfer of the byte to complete
    return SPDR;                                    // return the byte received from the master
}

void loop() {
    switch (digitalRead(pin::SS)) { 
        case HIGH: {                                // if the SS line is HIGH, we're not selected, no sampling and the like
            if (usingMISO) {                        // if we previously used MISO in low Z mode, set it to high Z so that it won't interfere with other devices using the SPI bus
                pinMode(pin::MISO, INPUT);               // MISO set to high impedance
                usingMISO = false;                  // remember that we've not used it
            }
            if(dataReady) {                         // if the data has already been sampled, do nothing and go check the SS line again
                break;
            }
                                                    // do work when not transferring data
                                                    // from here to the end of the case, the execution time is about 70 us
            sampleInput();                          // read data from the inputs: ENCODERoders, buttons and thermistors
            if(millis() - last_update > delta - 5) {// the Pi is about to send a request for data, sample the thermistors once, since we don't need every change in temp
                buffer[4]=getTemperaturePSU(analogRead(PSU_TEMPERATURE_SENSE));
                buffer[5]=getTemperatureCHA(analogRead(CHANNELA_TEMPERATURE_SENSE));
                buffer[6]=getTemperatureCHB(analogRead(CHANNELB_TEMPERATURE_SENSE));

                dataReady = true;                   // mark that the data is all ready in the buffer so that if the SS is high next loop, we know not to sample again
            }
            break;
        }
        case LOW: {                                 // SS line low, slave now selected, time to talk to the Pi
            if (!usingMISO) {                       // if we weren't using MISO as output in the prev. loop, set it to low Z
                pinMode(pin::MISO, OUTPUT);         // MISO configured to output data
                usingMISO = true;                   // remember that we're used it
            }
                                                    // send the data in the buffer and receive the updated status
            for(uint8_t i=0; i<buffer_size; i++)
                buffer[i] = SPISendByte(buffer[i]);
            
            delta = buffer[0];                      // the master responds with the time between 2 consecutive requests
            
            buffer = {0};                           // 0 out the buffer to prepare for the next transaction

            dataReady = false;                      // data is not ready not, we're just sent it and we need new samples
            last_update = millis();                 // mark the time since the last SPI transaction
            break;
        }
    }
}
